 # Regular Expressions
+ Regular expressions is a set of characters that describes a search pattern.
+ Mostly, we use it to search for a presence of a string or in a text. (pattern-matching)
+ We can use them extract all the email addresses of a web page as well as filter nmap results.

##### Basic concepts
+ A regular expression is usual delimited by a forward slash in all languages:
```ruby
/regexp body/
```

+ A body of a regular expression contains ordinary regular expression characters, special characters and strings.
+ Example, the `=~` is the Ruby basic pattern matching operator. It returns `nil` if the string does not contain the pattern, otherwise it returns the index where the **first** match begins.

```ruby
>>
>> "Hi Regular Expression!!!" =~ /Express/
=> 11
>> 
>> "Hi Regular Expression!!!" =~ /express/
=> nil
>> 
```

##### Regexp object
+ Regular expressions are instances of the Regexp class, therefore they are Regexp objects.
+ You can create a regexp object with:
	+ Literal notation (`/pattern/`).
	+ `%r` notation.
	+ OO notation.
+ The `%r` notation works like `%` notation of strings. The `r` tells the interpreter to treat the string inside the delimiter as a regular expression.
+ Similar to the strings notation, *delimiters* are custom.
```ruby
>> 
>> /hello/ # â†’ Literal notation
=> /hello/
>> 
>> %r{hello} # â†’ {} delimiters
=> /hello/
>> 
>> %r!hello! # â†’ ! delimiter
=> /hello/
>> 
>> # OO notation
>> Regexp.new("hello")
=> /hello/
>> Regexp.compile("hello") # Regexp.compile or Regexp.new is the same.
=> /hello/
```

##### Regexp object
+ When you create a Regexp, you can add some flags to specify additional information about the matching that has to be performed.
+ If you use a literal notation you can add a character modifier after the last `/` of the Regexp. The most commonly used modifier is the `i` character.
+ It is used for case **in**sensitive matching. As we can see, when we add **i**, Ruby returns the index of the match.

```ruby
>> 
>> "Hello World!!!" =~ /hello/
=> nil
>> "Hello World!!!" =~ /hello/i
=> 0
>> 
>> "Hello World!!!" =~ /world/
=> nil
>> "Hello World!!!" =~ /world/i
=> 6
>> 
```

+ If you use OO notation, you should specify the correct attribute when you create the Regexp.

```ruby
>> 
>> reg = Regexp.new("hello",Regexp::IGNORECASE)
=> /hello/i
>> 
>> "Hello World!!!" =~ reg
=> 0
>> 
>> 
>> reg = Regexp.new("hello",Regexp::IGNORECASE)
=> /hello/i
>> 
>> "Hello World!!!" =~ reg
=> 0
>> 
```

+ There are more here: [ https://ruby-doc.org/core-1.9.3/Regexp.html ]

##### Match method
+ If you have a Regexp object and you invoke match on a string, it gives you another object that describes the match (a **MatchData** object).
+ With a **MatchData** object, you can get some information about the matching such as the position of the matched substring, the matched words and much more.
+ You can treat **MatchData** as an array - where at each position you can find the matching substring.
+ Example: 
```ruby
>> 
>> # No matching
>> result = /pass/.match("Password: Passw@rd123!")
=> nil
>> 
>> # Adding i modifier to ignore case sensitive
>> result = /pass/i.match("Password: Passw@rd123!")
=> #<MatchData "Pass">
>> 
>> # first result sub-string is
>> result[0]
=> "Pass"
>> 
>> # no other matching sub-string
>> result[1]
=> nil
>> 
>> # index of first matching string
>> result.begin(0)
=> 0
>> 
```


##### Special characters
+ There are some characters with special meanings:
+ `()`, `[]`, `{}`, `.`, `?`, `+`, `*`, `|`, `^`, `$`
+ Example:
```ruby
>> 
>> "(Password: P@assW0rld123_)" =~ /\(/
=> 0
>> 
>> "[Password: P@assW0rld123_]" =~ /\[.*\]/
=> 0
>> 
>> "Password: P@assW0rld123_" =~ /\_/
=> 23
>> 
>> "Password: P@assW0rld123_?" =~ /\?/
=> 24
>> 
```

##### Regular Expression Syntax
+ More POWERFUL regular expression syntax.
###### Character classes
The most common rules are the following:

| Rule   | Matching                                                  |
| ------ | --------------------------------------------------------- |
| `.`    | A single character (does not match newline)               |
| `[]`   | At least one of the character in the square brackets.     |
| `[^ ]` | At least one of the character **not** in square brackets. |
| `\d`   | A digit. Same as `[0-9]` (from 0 to 9).                   |
| `\D`   | A non digit characters. Same as `[^0-9]`.                 |
| `\s`   | A whitespace.                                             |
| `\S`   | A non whitespace.                                         |
| `\w`   | A word character, same as `[A-Za-z0-9]`.                  |
| `\W`   | A non word characters.                                    |

```ruby
>> # The string not contains character `p`, `z` or `c`
>> password = /[pzc]/.match("Password: Passw@rd123!")
=> nil
>> 
>> # The string contains character `p` if ignore case sensitive
>> # `p` at the index 0
>> password = /[pzc]/i.match("Password: Passw@rd123!")
=> #<MatchData "P">
>> 
>> password = /\s(P\w+.\w+\W+)/i.match("Password: Passw@rd123!")
=> #<MatchData " Passw@rd123!" 1:"Passw@rd123!">
>> 
```

###### Sequences
+ A sequence is just a concatenation of regular expression. The string must match the resulting concatenated pattern.

| Rule | Matching                                              |
| ---- | ----------------------------------------------------- |
| xy   | Regular expression x followed by regular expression y |

```ruby
>> 
>> # Match any word start with net
>> password = /net\w+/.match("Pass: netadministrator@123")
=> #<MatchData "netadministrator">
>> 
>> # Catch special character with `.` regexp
>> password = /net\w+./.match("Pass: netadministrator@123")
=> #<MatchData "netadministrator@">
>> 
>> # `\d+` to search all the number.
>> password = /net\w+.\d+/.match("Pass: netadministrator@123")
=> #<MatchData "netadministrator@123">
>> 
```

+ Alternatively, `|` pipe character are used to specify that the string must match at least one of the two (or more) regular expression.

| Rule | Matching                                            |
| ---- | --------------------------------------------------- |
| x\|y | Either regular expression x or regular expression y |

```ruby
>> 
>> string = /\w|\./.match("I'am 21 years old")
=> #<MatchData "I">
>> 
>> string = /\d|\w/.match("I'am 21 years old")
=> #<MatchData "I">
>>
```

###### Groups
+ The special characters `()` are used to group a regular expression into a unique syntactic unit.

| Rule  | Matching                        |
| ----- | ------------------------------- |
| (exp) | exp is grouped as a single unit |

```ruby
>> 
>> "I'm a Rubber" =~ /Rub(y|ber)/
=> 6
>> 
>> "I'm a Ruber" =~ /Rub(y|ber)/
=> nil
>> 
```

+ Groups are used to capture more than one pattern inside a string.
```ruby
>>
>> password = /(\s)(P\w+.\w+\W+)/i.match("Password: Passw@rd123!")
=> #<MatchData " Passw@rd123!" 1:" " 2:"Passw@rd123!">
>> password[1]
=> " "
>> password[2]
=> "Passw@rd123!"
>> password[0]
=> " Passw@rd123!"
>> 
```

##### Repetitions
+ Repetitions are one of the most used syntax rules of regular expression.

| Rule     | Matching                                     |
| -------- | -------------------------------------------- |
| exp*****     | Zero or more occurrences of exp              |
| exp**+**     | One or more occurences of exp                |
| exp**?**     | Zero or one occurrence of exp                |
| exp**{n}**   | n occurrences of exp (N is a natural number) |
| exp**{n,}**  | n or more occurrences of exp                 |
| exp**{n,m}** | at least n and at most m occurrences of exp  |

```ruby
>> 
>> target_ip = /([0-9]{1,3}.){4}/.match("IP: 192.168.0.241")
=> #<MatchData "192.168.0.241" 1:"241">
>> 
>> target_ip[0]
=> "192.168.0.241"
```

##### Anchors
+ Anchors are used to specify the position of the pattern matching. The most commonly used are:

| Rule      | Matching                                     |
| --------- | -------------------------------------------- |
| **\^**exp | exp must be at the beginning of a line       | 
| exp**$**  | exp must be at the end of a line             |
| **\A**exp | Exp must be at the begin of the whole string |
| exp**\Z** | exp must be at the end of the whole string   |
| exp**\z** | same as **\Z** but match newline too         |

```ruby
>> 
>> "Hello World" =~ /^Hello/
=> 0
>> "Hello World" =~ /\AHello/
=> 0
>> 
>> # String does not start with 'A'
>> "Hello World" =~ /^A/
=> nil
>> 
>> "Hello World" =~ /^\AA/
=> nil
>> 
>> # string ends with "World"
>> 
>> "Hello World" =~ /World$/
=> 6
>> "Hello World" =~ /World\z/
=> 6
>> "Hello World" =~ /World\Z/
=> 6
>> 
>> # string does not end with 'l'
>> "Hello World" =~ /l$/
=> nil
>> "Hello World" =~ /d$/
=> 10
>> 
```

+ When you have multi-line strings use them carefully. For example:
```ruby
>> 
>> "aaa
 | bbb
 | ccc" =~ /^bb/
=> 4
>> 
>> "aaaa
 | bbb
 | ccc" =~ /\Abb/
=> nil
>> 
>> "aaa
 | bbb
 | ccc" =~ /bb$/
=> 5
>> 
>> "aaa
 | bbb
 | ccc" =~ /bb\z/
=> nil
>> 
>> "aaa
 | bbb
 | ccc" =~ /bb\Z/
=> nil
```

+ Difference between `\z` and `\Z`. Remember that `\Z` ignores new lines.
```ruby
>> # no difference when
>> # new line isn't the last character
>> 
>> "aaa
 | bbb" =~ /bb\Z/
=> 5
>> 
>> "aaa
 | bbb" =~ /bb\z/
=> 5
>> 
>> # when new line the last character
>> "aaa
 | bbb
 | " =~ /bb\Z/
=> 5
>> 
>> "aaa
 | bbb
 | " =~ /bb\z/
=> nil
>> 
```

###### A real-world example
+ Extract IPv4 address
```ruby
>> 
>> ip = /(\d{1,3}.){4}/.match("192.168.0.245")
=> #<MatchData "192.168.0.245" 1:"245">
>> 
```

**Important**: The previous regular expression does not identify only the IP address. What happens if the string contains **999.999.999.999**?
```ruby
>> ip = /(\d{1,3}.){4}/.match("Some test ... 999.999.999.999")
=> #<MatchData "999.999.999.999" 1:"999">
>> 
>> ip.to_a
=> ["999.999.999.999", "999"]
```

+ As we can see, the regular expression also matchs, but it is not a vaild IP address.

##### Regular Expressions in the Ruby platform
###### Global Variables
+ When you work with regular expression operators (the `=~` operator). Ruby automatically sets some global variable. The most useful are:

| Variable           | Description                                         |
| ------------------ | --------------------------------------------------- |
| `$~`               | The MatchData object of the last match              |
| `$&`               | The substring that matches the first group pattern  |
| `$1`               | The substring that matches the second group pattern |
| `$2`, `$3`, etc... | And so on...                                        |

+ Example:
```ruby
>> 
>> "Hello World!!!" =~ /^(hello)\s(world)(!!!)$/i
=> 0
>> 
>> $&
=> "Hello World!!!"
>>
>> $~
=> #<MatchData "Hello World!!!" 1:"Hello" 2:"World" 3:"!!!">
>> 
>> $1
=> "Hello"
>> 
>> $2
=> "World"
>> 
>> $3
=> "!!!"
```

+ An important thing to know is that `$~` is the most important variable because all of the others (`$&`, `$1`, `$2`...) are derived from it.
+ Moreover, `$~` is thread and method local, i.e. each thread has its own `$~` and they do not interfere with each other. Therefore, if you use multi threaded programming style, you can use `$~` without any problem in each thread.

###### Working with Strings
+ You can use regexp for all the methods that we have seen so far: `sub`, `gsub`, `split` and more.

```ruby
>> ip = "Here is our internal IP addresses in the network: 192.168.0.24, 192.168.0.242, 192.168.0.3, and 192.168.0.222. Others are out of scope"
=> "Here is our internal IP addresses in the network: 192.168.0.24, 192.168.0.242, 192.168.0.3, and 192.168.0.222. Others are out of scope"
>> 
>> ip.match(/(\d{1,3}.){3}\d{1,3}/)
=> #<MatchData "192.168.0.24" 1:"0.">
```

+ A useful String method that we can use is `scan`. Imagine that we want to extract all of the occurences of a particular pattern in a text. If we use `u~` or `match`, it will only return the first matching one.
+ `scan` instead allows you to iterate through more occurrences of the text matching in the pattern.

```ruby
>> ip.scan(/(?:\d{1,3}.){3}\d{1,3}/) { |x| puts x }
192.168.0.24
192.168.0.242
192.168.0.3
192.168.0.222
=> "Here is our internal IP addresses in the network: 192.168.0.24, 192.168.0.242, 192.168.0.3, and 192.168.0.222. Others are out of scope"
>>
>> ip.scan(/(?:\d{1,3}.){3}\d{1,3}/) 
=> ["192.168.0.24", "192.168.0.242", "192.168.0.3", "192.168.0.222"]
```

+ In the example, we have used a special regexp syntax. This syntax avoids capturing the subexpression inside `()`, so only the entire external expression is captured. (the IP address).

<hr>

# Dates and time
+ There are three main ways to treat them in Ruby (different classes):
	+ Time
	+ Date
	+ DateTime

##### Time Class
+ Time class provides methods to work with your operating system date and time functionality

###### Create a time instance
+ Time instances can be created using different ways and time zone. To create a current time object:

```ruby
>> 
>> # Current system time
>> Time.new
=> 2021-08-14 02:14:48.620481765 -0400
>> 
>> Time.now
=> 2021-08-14 02:15:01.294132942 -0400
>> 
>> # Current time converted in UTC
>> Time.new.utc
=> 2021-08-14 06:15:54.861380636 UTC
```

+ You can also create an arbitrary time object.

```ruby
>> 
>> Time.local(2014)
=> 2014-01-01 00:00:00 -0500
>> 
>> Time.local(2014,3)
=> 2014-03-01 00:00:00 -0500
>> 
>> Time.local(2014,3,15)
=> 2014-03-15 00:00:00 -0400
>> 
>> Time.local(2014,3,15, 4)
=> 2014-03-15 04:00:00 -0400
>> 
>> Time.local(2014,3,15, 4,18)
=> 2014-03-15 04:18:00 -0400
>> 
>> Time.local(2014,3,15, 4,18,30)
=> 2014-03-15 04:18:30 -0400
>> 
>> Time.utc(2021,3,15, 5,18,22)
=> 2021-03-15 05:18:22 UTC
```

+ `Time.local` (recommended*) is a symnonymous for `Time.new`.

###### Components of a time
+ Time class provides a lot of useful methods to extract fields on a time object. 
+ Example:

```ruby
>> time = Time.new
=> 2021-08-14 02:22:37.638353969 -0400
>> 
>> time.year
=> 2021
>> 
>> time.month
=> 8
>> 
>> time.day
=> 14
>> 
>> time.hour
=> 2
```

###### Predicates and conversions
+ Time also provides some useful predicates.
```ruby
>> 
>> time = Time.now
=> 2021-08-14 02:25:31.616323072 -0400
>> 
>> time.tuesday?
=> false
>> 
>> time.saturday?
=> true
```

+ Conversion between zone may be useful too.
+ Example:

```ruby
>> 
>> t = Time.new.utc
=> 2021-08-14 06:27:12.539508431 UTC
>> 
>> t.zone
=> "UTC"
>> 
>> t.localtime
=> 2021-08-14 02:27:12.539508431 -0400
>> 
>> t.zone
=> "EDT"
```

+ Moreover, we can also converse a time to a timestamp, an array and more.
```ruby
>> 
>> t = Time.new
=> 2021-08-14 02:28:28.580374025 -0400
>> 
>> # timestamp
>> t.to_i
=> 1628922508
>> 
>> # an array
>> t.to_a
=> [28, 28, 2, 14, 8, 2021, 6, 226, true, "EDT"]
```

###### Arithmetic
+ You can use simple operations with time (`+` and `-`) in order to add seconds to your time object.

```ruby
>> 
>> time = Time.now
=> 2021-08-14 02:32:33.912104563 -0400
>> 
>> time + 20
=> 2021-08-14 02:32:53.912104563 -0400
>> 
>> time + 3600
=> 2021-08-14 03:32:33.912104563 -0400
```

+ If you want to perform more operations on Time and Dates, you can install a very useful gem named `active_support`. This gem adds some more useful methods when you work with time arithmetic:

```bash
$ gem install -r active_support

# If not work, try
$ gem install -r activesupport
```

+ The Numeric class will now have methods like days, week, and so on.

```bash
>> 
>> require 'active_support/core_ext/numeric/time'
=> true
>> t = Time.now
=> 2021-08-14 02:38:54.063164889 -0400
>> 
>> t + 10.days
=> 2021-08-24 02:38:54.063164889 -0400
>> 
>> t + 1.week
=> 2021-08-21 02:38:54.063164889 -0400
```

+ If you do not want to install gem, you can also write a function version of helper. Remember that classes are open so you can add methods to them.
+ In the following example, we add function `days` to the *Numeric* class. This methods simply converts a number into days (amount of seconds).

```ruby
>> class Numeric
 |   def days; self*24*60*60; end
 | end  
=> :days
>> 
>> t = Time.now
=> 2021-08-14 02:43:09.99521169 -0400
>> 
>> t + 10.days
=> 2021-08-24 02:43:09.99521169 -0400
```

###### Comparisons
+ If you take a look to `Time` class, you will see that it includes `Comparable` module (via mixin).
+ This means that you can use basic comparison operators such as:
`>`, `<`, `>=`, `<=` and more.

```ruby
>> 
>> time = Time.now
=> 2021-08-14 02:47:50.412622961 -0400
>> 
>> before = time - 20
=> 2021-08-14 02:47:30.412622961 -0400
>> 
>> after = time + 20
=> 2021-08-14 02:48:10.412622961 -0400
>> 
>> time > before
=> true
>> 
>> time < after
=> true
>>
>> before + 40 == after
=> true
```

###### From time to string

+ There are many more other methods that we can use on Time objects.

For example, you can object a string `to_s` or `ctime` method according to the format you want.

```ruby
>> 
>> t = Time.new
=> 2021-08-14 02:50:27.260048342 -0400
>> 
>> t.to_s
=> "2021-08-14 02:50:27 -0400"
>> 
>> t.getutc.to_s
=> "2021-08-14 06:50:27 UTC"
>> 
>> t.ctime
=> "Sat Aug 14 02:50:27 2021"
>> 
>> t.getutc.ctime
=> "Sat Aug 14 06:50:27 2021"
```

+ Another useful method is `strftime`
+ Directive begin with the `%` character:
```md
%Y%m%d           => 20071119                  Calendar date (basic)
%F               => 2007-11-19                Calendar date (extended)
%Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month
%Y               => 2007                      Calendar date, reduced accuracy, specific year
%C               => 20                        Calendar date, reduced accuracy, specific century
%Y%j             => 2007323                   Ordinal date (basic)
%Y-%j            => 2007-323                  Ordinal date (extended)
%GW%V%u          => 2007W471                  Week date (basic)
%G-W%V-%u        => 2007-W47-1                Week date (extended)
%GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)
%G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)
%H%M%S           => 083748                    Local time (basic)
%T               => 08:37:48                  Local time (extended)
%H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)
%H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)
%H               => 08                        Local time, reduced accuracy, specific hour
%H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
%T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
%H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
%T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
%H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)
%T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)
%Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)
%FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
%Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)
%Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
%GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)
%G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
%Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)
%FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)
%Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)
%Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)
%GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
%G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)
```

+ Example: `strftime`
```ruby
>> t = Time.now
=> 2021-08-14 02:55:29.197928827 -0400
>> 
>> t.strftime("%Y/%m/%d")
=> "2021/08/14"
>> 
>> t.strftime("%d-%m-%Y")
=> "14-08-2021"
>> 
>> t.strftime("%H:%M:%S")
=> "02:55:29"
>> 
>> t.strftime("%I:%M:%S")
=> "02:55:29"
>> t.strftime("%I:%M:%S %P")
=> "02:55:29 am"
>> 
>> 
>> t.strftime("%I:%M:%S %p %Z")
=> "02:55:29 AM EDT"
```

+ There are also some combination directives.

##### Other classes
+ **Date**: is used to manage date
+ **DateTime**: it is subclass of *Data* and it allows to manage time too. 

+ Using the class **Time** is fine for now.

<hr>

# Files and Directories
+ Ruby provides two classes:
	+ **Dir**: for directories.
	+ **File**: for files.

#### Directories
##### Current Directory
+ **Dir** class allows you to work with directories.

```ruby
pry --simple-prompt 
>> 
>> Dir.pwd
=> "/root/Desktop/study_ruby/pentester_ruby"
>> Dir.getwd
=> "/root/Desktop/study_ruby/pentester_ruby"
```

+ The `home` method instead returns the home directory of the current user, or home directory of the given user.

```ruby
>> 
>> Dir.home
=> "/root"
>> 
>> Dir.home("www-data")
=> "/var/www"
>> 
>> Dir.home("jax")
ArgumentError: user jax doesn't exist
from (pry):5:in `home'
```

##### Change Directory
+ Another useful method is `chdir`.
+ It can be used to change the current working directory.
```ruby
>> 
>> Dir.pwd
=> "/root/Desktop/study_ruby/pentester_ruby"
>> 
>> Dir.chdir("..")
=> 0
>> 
>> Dir.pwd
=> "/root/Desktop/study_ruby"
>> 
>> Dir.chdir("/root")
=> 0
>> 
>> Dir.pwd
=> "/root"
```

+ You can also specify a block after `chdir` method invocation. In this case, the block is executed in the new specified director but the original one is restored when the block exists.

```ruby
#!/usr/bin/ruby

puts Dir.pwd

Dir.chdir("/root") do
  puts Dir.pwd
end

puts Dir.pwd

#------------------------

./chdir.rb                                                                 
/root/Desktop/study_ruby/pentester_ruby
/root
/root/Desktop/study_ruby/pentester_ruby
```

##### Creation / Deletion
+ Create a working directory with Ruby can be done via `mkdir` method.

```ruby
>> Dir.pwd
=> "/root/Desktop/study_ruby/pentester_ruby"
>> 
>> Dir.mkdir("new_dir")
=> 0
>> 
>> Dir.chdir("new_dir")
=> 0
>> 
>> Dir.pwd
=> "/root/Desktop/study_ruby/pentester_ruby/new_dir"
```

+ We can delete an existing directory with the following methods: `delete`, `rmdir`, `unlink`.

```ruby
>> 
>> Dir.chdir("new_dir")
=> 0
>> 
>> Dir.pwd
=> "/root/Desktop/study_ruby/pentester_ruby/new_dir"
>> 
>> Dir.chdir("..")
=> 0
>> 
>> Dir.rmdir("new_dir")
=> 0
>> 
>> Dir.chdir("new_dir")
Errno::ENOENT: No such file or directory @ dir_s_chdir - new_dir
from (pry):5:in `chdir'
```

+ If you try do delete a non empty directory, a **SystemCallError** will be raised.

```ruby
>> Dir.mkdir("test") 
=> 0
>> 
>> Dir.chdir("test") do
 |   Dir.mkdir("another_test")
 | end  
=> 0
>> 
>> Dir.rmdir("test")
Errno::ENOTEMPTY: Directory not empty @ dir_s_rmdir - test
from (pry):11:in `rmdir'
```

##### Directory Listings
+ Method `entries` will return an array containing all files in the given directory.

```ruby
>> Dir.entries("/root/Desktop/study_ruby/pentester_ruby")
=> ["test", "..", ".", "chdir.rb"]
```

+ If we create an iterator, we can use `foreach`.

```ruby
>> Dir.foreach(".") do |file|
 |   puts file
 | end  
test
..
.
chdir.rb
=> nil
```

+ Or we can also use `for` loop.

```ruby
>> for file in Dir.entries(".") do
 |   puts file
 | end  
test
..
.
chdir.rb
```

+ `Glob` method or `[]` allows you to search files or directories in the file system, according to a specific pattern.

**NOTE**: The pattern here is not a regular expression. It's closer to a [shell glob](https://en.wikipedia.org/wiki/Glob_(programming)).

```ruby
>> Dir["*.rb"]
=> ["ex.rb", "ex2.rb", "chdir.rb", "ex1.rb"]
>> 
>> Dir["???.rb"]
=> ["ex2.rb", "ex1.rb"]
>> 
>> Dir["??.rb"]
=> ["ex.rb"]
>>
>> Dir.glob("*.rb")
=> ["ex.rb", "ex2.rb", "chdir.rb", "ex1.rb"]
```

##### Testing Directories
+ `exist?` or `exists?` is used to test if the specified path is directory.

```ruby
>> Dir.exist? "/root"
=> true
>> 
>> Dir.exist? "/var/www/html"
=> true
>> 
>> Dir.exist? "/opt/ruby"
=> false
```

##### Dir Objects
+ `Dir` class can be instantiated too. Using this strategy, you have an object that represents a Directory and you can use the object instance methods instead of class methods.

```ruby
>> dir = Dir.new(".")
=> #<Dir:.>
>> 
>> dir.each {|file| puts file}
ex.rb
test
..
ex2.rb
.
chdir.rb
ex1.rb
=> #<Dir:.>
```

#### Files
##### Testing Files
+ Same as dir, we can check if a file exists using `exists?` or `exist` method.

```ruby
>> Dir.entries(".")
=> ["check_ssh.rb", "ex.rb", "test", "..", "ex2.rb", ".", "chdir.rb", ".check_ssh.rb.swp", "ex1.rb"]
>> 
>> File.exists? "ex.rb"
=> true
>> 
>> File.exists? "ex3.rb"
=> false
```

+ The size method is used to test size of a file in bytes.
	+ `size?` will return the size in bytes or *nil* if the file is empty.
	+ `zero?` returns true if the file is empty.

```ruby
>> File.size("check_ssh.rb")
=> 446
>> 
>> File.size? "ex.rb"
=> nil
>> 
>> File.zero? "ex.rb"
=> true
```

+ The following methods:
	+ `file?`,  check if the argument is file.
	+ `directory?`,  check if the argument is directory.
	+ `symlink?`,   check if the argument is symbolic link.

```ruby
â”Œâ”€â”€(rootðŸ’€jaeng)-[~/Desktop/study_ruby/pentester_ruby]
â””â”€# ls    
chdir.rb  check_ssh.rb  ex1.rb  ex2.rb  ex_dir  ex.rb  test
â”Œâ”€â”€(rootðŸ’€jaeng)-[~/Desktop/study_ruby/pentester_ruby]
â””â”€# pry --simple-prompt>> File.file? "ex.rb"
>> File.file? "ex.rb"
=> true
>> 
>> Dir.mkdir("ex_dir")
=> 0
>> 
>> File.directory? "ex_dir"
=> true
>> 
>> File.symlink? "test"
=> true
```

+ Another useful method is `ftype`. It tests if it is a file, a directory or a link.

```ruby
â”Œâ”€â”€(rootðŸ’€jaeng)-[~/Desktop/study_ruby/pentester_ruby]
â””â”€# ls    
chdir.rb  check_ssh.rb  ex1.rb  ex2.rb  ex_dir  ex.rb  test  
â”Œâ”€â”€(rootðŸ’€jaeng)-[~/Desktop/study_ruby/pentester_ruby]
â””â”€# pry --simple-prompt
>> 
>> File.ftype "ex_dir"
=> "directory"
>> 
>> File.ftype "ex2.rb"
=> "file"
>> 
>> File.ftype "test"
=> "link"
```

+ Method such as `readable?`, `writable?` and `executable?` can be used to test permissions.

```ruby
>> File.readable? "test"
=> true
>> 
>> File.writable? "test"
=> true
>> 
>> File.executable? "chdir.rb"
=> true
```

+ `mtime` and `atime` returns respectively the last modification time and the last access time as a Time object. So you can use TIme methods.

```ruby
>> at = File.atime "ex1.rb"
=> 2021-08-16 06:43:03.020397164 -0400
>> at.getutc
=> 2021-08-16 10:43:03.020397164 UTC
>> 
>> mt = File.mtime "ex1.rb"
=> 2021-08-16 06:43:03.020397164 -0400
>> 
>> mt.getutc
=> 2021-08-16 10:43:03.020397164 UTC
```

+ `ctime` can be used instead on Microsoft Windows platform to retrieve the creation time.

```ruby
>> File.ctime("ex1.rb")
=> 2021-08-16 06:43:03.020397164 -0400
```

+ We can use  `stat` method to list all common status information about the current file.

```ruby
>> st = File.stat "ex1.rb"
=> #<File::Stat
 dev=0x801,
 ino=2754820,
 mode=0100644 (file rw-r--r--),
 nlink=1,
 uid=0 (root),
 gid=0 (root),
 rdev=0x0 (0, 0),
 size=0,
 blksize=4096,
 blocks=0,
 atime=2021-08-16 06:43:03.020397164 -0400 (1629110583),
 mtime=2021-08-16 06:43:03.020397164 -0400 (1629110583),
 ctime=2021-08-16 06:43:03.020397164 -0400 (1629110583)>
>> 
>> st.size
=> 0
>> st.uid
=> 0
>> st.atime
=> 2021-08-16 06:43:03.020397164 -0400
```

##### Working with names
+ `basename` method can be used to extract the file name from a path. If you specify the suffix argument then the suffix itself is removed from result.

```ruby
>> file = "/root/Desktop/study_ruby/pentester_ruby/ex1.rb"
=> "/root/Desktop/study_ruby/pentester_ruby/ex1.rb"
>> 
>> File.basename file
=> "ex1.rb"
>> 
>> File.basename file, ".rb"
=> "ex1"
```

+ `dirname` can be used to extract only the directory part of a path string. This will cut the last part from the string.

```ruby
>> file = "/root/Desktop/study_ruby/pentester_ruby/ex1.rb"
=> "/root/Desktop/study_ruby/pentester_ruby/ex1.rb"
>> 
>> File.dirname file
=> "/root/Desktop/study_ruby/pentester_ruby"
```

+ `extname` can be used to extract file extension name.
+ `split` returns an array containing both *dirname* and *basename*.

```ruby
>> file = "/root/Desktop/study_ruby/pentester_ruby/ex1.rb"
=> "/root/Desktop/study_ruby/pentester_ruby/ex1.rb"
>>
>> File.extname file
=> ".rb"
>> 
>> File.split file
=> ["/root/Desktop/study_ruby/pentester_ruby", "ex1.rb"]
```

+ A useful method that allows us to create string paths is `join`. 

```ruby
>> File.join("~","ruby","test_file")
=> "~/ruby/test_file"
>> 
>> File.join("", "root","ruby","test_file")
=> "/root/ruby/test_file"
```

+ `expand_path` is used to convert relative path to absolute path.

```ruby
>> 
>> Dir.pwd
=> "/root/Desktop/study_ruby/pentester_ruby"
>>
>> File.expand_path("test_expand")
=> "/root/Desktop/study_ruby/pentester_ruby/test_expand"
>> 
>> File.expand_path("~/Desktop")
=> "/root/Desktop"
>> 
>> File.expand_path("Documents", "/root")
=> "/root/Documents"
```

+ Another useful method is `fnmatch`. It tests if a filename string matches a specfied pattern. The file pattern is not a regular expression but it is the usual glob syntax.

```ruby
>> File.fnmatch("*.rb", "test")
=> false
>> 
>> File.fnmatch("*.rb", "ex1.rb")
=> true
>> 
>> File.fnmatch("/*/*.rb", "ex1.rb")
=> false
>> 
>> File.fnmatch("/*/*.rb", "/root/ex1.rb")
=> true
```

##### Creation / Deletion / Renaming
###### Creation
+ `open` used with the `w` modifier creates a file.

```ruby
>> 
>> File.open("a_file.txt", "w")
=> #<File:a_file.txt>
>> 
>> Dir.entries "."
=> ["a_file.txt", "check_ssh.rb", "ex_dir", "ex.rb", "test", "..", "ex2.rb", ".", "chdir.rb", "ex1.rb"]
```

+ Instead of `open`, we can use `new` to create a new file.

```ruby
>> File.new("a_file.txt", "w")
=> #<File:a_file.txt>
>> 
>> Dir.entries "."
=> ["a_file.txt", "check_ssh.rb", "ex_dir", "ex.rb", "test", "..", "ex2.rb", ".", "chdir.rb", "ex1.rb"]
```

###### Renaming
+ `rename` can be used to rename a file.

```ruby
>> Dir.entries "."
=> ["a_file.txt", "check_ssh.rb", "ex_dir", "ex.rb", "test", "..", "ex2.rb", ".", "chdir.rb", "ex1.rb"]
>>
>> File.rename("a_file.txt", "b_file.txt")
=> 0
>> 
>> Dir.entries "."
=> ["check_ssh.rb", "ex_dir", "ex.rb", "test", "..", "ex2.rb", ".", "chdir.rb", "b_file.txt", "ex1.rb"]
```

###### Deletion
+ `delete` and `unlink` can be used to delete a file.

```ruby
>> File.delete "b_file.txt"
=> 1
```


##### Change permission
+ `chmod` can be used to change file permission.

```ruby
â”Œâ”€â”€(rootðŸ’€jaeng)-[~/Desktop/study_ruby/pentester_ruby]
â””â”€# ls -al ex1.rb       
-rw-r--r-- 1 root root 0 Aug 16 06:43 ex1.rb

â”Œâ”€â”€(rootðŸ’€jaeng)-[~/Desktop/study_ruby/pentester_ruby]
â””â”€# pry --simple-prompt
>> File.chmod(0777, "ex1.rb")
=> 1
>> exit
  
â”Œâ”€â”€(rootðŸ’€jaeng)-[~/Desktop/study_ruby/pentester_ruby]
â””â”€# ls -al ex1.rb      
-rwxrwxrwx 1 root root 0 Aug 16 06:43 ex1.rb
```

+ We can also use `chown` method to change owner of the file.